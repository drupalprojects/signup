<?php
// $Id$

//  TODO's
//  1. add support limiting signups to certain roles, per node
//  2. veiwing/manual opening of closed signups
//  3. make datetime display dependent on medium date format display setting in admin/settings
//  4. adding support for custom auto-closing settings per node: time before event start, number of signups
//  5. better header info for emails sent to forwarding email address?
//  6. validation of forwarding email addresses
//  7. validation of user submitted data
//  8. catch remote user logins and get their email addy (currently signup relies on the email addy of a registered user for
//     confirmation/reminder emails)
//  9. support for admin own signups
//  10. user page support where users can see a list of the events they've signed up for
//  11. ability for admins to cancel signups from the signup tab
//  12. feature to allow event admins to email signup group
//  13. fix reminder message notification so it doesn't display on signups where reminder has already been sent
//  14. make display of reminder email info conditional on whether node is event enabled (form edit page)
//  15. better themed user signup form?

include(drupal_get_path('module', 'signup') . '/signup.theme');

/**
 * @defgroup signup_core Core drupal hooks
 */

/**
 * Implementation of hook_block().
 * @ingroup signup_core
 * @param $op the operation that is being requested.  This defaults to 'list', which indicates that the method should
 *        return which blocks are available.
 * @param $delta the specific block to display.  This is actually the offset into an array.
 * @return one of two possibilities.  The first is an array of available blocks.  The other is an array containing a
 *        block.
 */
function signup_block($op = 'list', $delta = 0) {
  global $user;
  switch ($op) {
    case 'list' :
      $blocks[0]['info'] = t('List of users current signups.');
      return $blocks;
      break;
    case 'view' :
      if (user_access('access content')) {
        switch ($delta) {
          case 0:
            $titles = _signup_list_user_signups($user->uid);
            $conflicts = _signup_get_conflicts($user->uid);
            if (count($conflicts)) {
              $conflict_teaser = '<br>'. l(t('%number schedule %conflict', array('%number' => $conflicts['total'], '%conflict' => format_plural($conflicts['total'], t('conflict exists'), t('conflicts exist')))), "user/$user->uid");
            } else {
              $conflict_teaser = '';
            }
            if (count($titles) > 0) {
              $block['subject'] = t('Current Signups');
              $block['content'] = theme_item_list($titles) . l(t('view signup schedule'), "user/$user->uid/signups"). $conflict_teaser;
            }
            return $block;
        }
      }
  }
}

/**
 * Implementation of hook_cron().
 * @ingroup signup_core
 */
function signup_cron() {

  //only run this function if the event module is enabled
  if (module_exist('event')) {

    //get the current time, and pull all of the nodes for which the current time + the reminder_days_before time
    //is greater than the event's start date.  these are the events for which a reminder email needs to be sent
    $curtime = time();
    $result = db_query("SELECT n.title, n.nid, e.event_start, e.timezone, s.reminder_email, s.forwarding_email FROM {signup} s
      INNER JOIN {node} n ON n.nid = s.nid INNER JOIN {event} e ON e.nid = s.nid WHERE s.completed = 0 AND
      s.send_reminder = 1 AND (%d + ((s.reminder_days_before) * 86400)) > e.event_start", $curtime);

    //grab each event, construct the email header and subject, and query the signup log to pull all users who are
    //signed up for this event
    while ($event = db_fetch_object($result)) {
      $header = "From: $event->forwarding_email\nReply-to: $event->forwarding_email\nX-Mailer:
        Drupal\nReturn-path: $event->forwarding_email\nErrors-to: $event->forwarding_email";
      $subject = t('Event reminder: %event', array('%event' => $event->title));
      $signups = db_query("SELECT u.name, u.mail FROM {signup_log} s_l INNER JOIN {users} u ON u.uid = s_l.uid
        WHERE s_l.nid = %d", $event->nid);

      //get timezone offset
      $offset = event_get_offset($event->timezone, $event->event_start);

      //loop through the users, composing their customized message and sending the email
      while ($signup = db_fetch_object($signups)) {
        $trans = array("%event" => $event->title, "%time" => _event_date(variable_get('signup_date_string', 'D, M jS, g:i A'),
        $event->event_start, $offset), "%username" => $signup->name, "%useremail" => $signup->mail);
        $message = strtr($event->reminder_email, $trans);
        user_mail($signup->mail, $subject, $message, $header);
      }

      //reminders for this event are all sent, so mark it in the database so they're not sent again
      db_query("UPDATE {signup} SET send_reminder = 0 WHERE nid = %d", $event->nid);
    }

    //calculate the closing time for the event, which is the current time + the number of hours before the event start
    //when closing is preferred.  query the database for all signup events which have a start time less than this,
    $closing_time = $curtime + (variable_get('signup_close_early', 1) * 3600);
    $result = db_query("SELECT s.nid FROM {signup} s INNER JOIN {event} e ON e.nid = s.nid WHERE
      s.completed = 0 AND e.event_start < %d", $closing_time);

    //loop through the results, calling the event closing function
    while ($signup = db_fetch_object($result)) {
      signup_close_signup($signup->nid, $cron = 'yes');
    }
  }
}

/**
 * Implementation of hook_help().
 * @ingroup signup_core
 */
function signup_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Allow users to sign up for events.');
      break;
    case 'admin/help#signup':
      return t('<p>Signup allows users to sign up for nodes of any type.  Includes options for sending a notification email to a selected email address upon a new user signup (good for notifying event coordinators, etc.) and a confirmation email to users who sign up--these options are per node.  When used on event nodes (with event.module installed and regular cron runs), it can also send out reminder emails to all signups X days before the start of the event (per node setting) and auto-close event signups 1 hour before their start (general setting). Settings exist for resticting signups to selected roles and content types.</p><br><p>To use signup, you must enable a node type for signups in administer->settings->content types, and you must also grant the \'allow signups\' permission to any user role for which you wish to allow signups in administer->access control. Each signup node will now have a place for users to sign up, and administrators with the \'admin signups\' privilege will be able to view signups for each signup node and see an overview of signups for all nodes (the overview is located in administer/signup)</p><br><p>Default settings for notification email address, reminder emails and confirmation emails are located in administer->settings->signup. These will be the default values used for a signup node unless otherwise specified (to configure these options per node, visit \'edit\' for that node and make the adjustments in the \'Sign up settings\' section)</p><br><p>Signups can be manually closed for any node at administer->signup.</p><br><p>The user signup form is fully themable--form fields may be added or deleted.  For more details see the instructions in signup.theme, where a sample user form is included</p>');
  }
}

/**
 * Implmentation of hook_menu()
 * @ingroup signup_core
 */
function signup_menu($may_cache) {

  global $user;
  $items = array();
  $access = user_access('admin signups');

  if ($may_cache) {

    //admin/settings/signup menu item
    $items[] = array('path' => 'admin/settings/signup', 'title' => t('signup'),
      'callback' => 'signup_settings_page',
      'access' => user_access('access administration pages'));

    //admin/signup menu item
    $items[] = array('path' => 'admin/signup', 'title' => t('signup'),
      'callback' => 'signup_admin_page',
      'access' => $access);
    $items[] = array('path' => 'admin/signup/overview', 'title' => t('overview'),
        'access' => $access, 'type' => MENU_DEFAULT_LOCAL_TASK, 'weight' => -10);
    $items[] = array('path' => 'admin/signup/conflicts', 'title' => t('conflicts'),
        'callback' => 'signup_conflict_summary', 'access' => $access,
        'type' => MENU_LOCAL_TASK, 'weight' => -5);
    $items[] = array('path' => 'admin/signup/conflict_detail', 'title' => t('conflict detail'),
        'callback' => 'signup_conflict_detail', 'access' => $access,
        'type' => MENU_LOCAL_TASK);

    //user signup callbacks
    $items[] = array('path' => 'signup', 'access' => TRUE, 'type' => MENU_CALLBACK, 'callback' => 'signup_user_signup');

    //close signup callback
    $items[] = array('path' => 'closesignup', 'access' => TRUE, 'type' => MENU_CALLBACK, 'callback' => 'signup_close_signup');
  } else {

    // user signup schedule callback
    $items[] = array('path' => 'user/' . arg(1) . '/signups', 'access' => ($access || ($user->uid == arg(1))), 'type' => MENU_CALLBACK,
    'callback' => 'signup_user_schedule');

    //if it's a signup event, then put in a signup tab
  	if (db_num_rows(db_query("SELECT nid FROM {signup} WHERE nid = %d", arg(1)))) {
  	  $node = node_load(array('nid'=>arg(1)));
      $items[] = array('path' => 'node/' . arg(1) . '/signups', 'title' => t('signups'),
          'callback' => 'signup_user_signups_form', 'callback arguments' => array($node),
          'access' => $access, 'type' => MENU_LOCAL_TASK, 'weight' => 20);

  	}
  }

  return $items;
}

/**
 * Implementation of hook_perm().
 * @ingroup signup_core
 */
function signup_perm() {
  return array('allow signups', 'admin signups');
}

/**
 * Implementation of hook_user().
 * @ingroup signup_core
 */
function signup_user($op, &$edit, &$user, $category = NULL) {
  switch ($op) {
    case 'view':

      //grab list of events the user signed up for
      $signups = _signup_list_user_signups($user->uid);
      if (count($signups) > 0) {
        $output = t('<h4>Current Signups -- '. l(t('view signup schedule'), "user/$user->uid/signups") .'<h4>') . theme_item_list($signups);
      }

      //grab list of signup conflict data for this user
      $conflicts = _signup_user_conflicts($user->uid);
      if (isset($conflicts)) {
        $output .= $conflicts['title'] . $conflicts['data'];
      }
      if (isset($output)) {
        return array(t('Signup information') => $output);
      }
  }
}

/**
 * @defgroup signup_nodeapi Functions for nodeapi integration
 */

 /**
 * hook_nodeapi implementation
 *
 * @ingroup signup_nodeapi
*/
function signup_nodeapi(&$node, $op, $arg = 0) {
  $edit = $_POST['edit'];
  switch ($op) {
    case 'settings':

      //inject this setting for all nodes types.  checking enables signups for the specified node type
      return form_checkbox(t('Allow signups'), 'signup_nodeapi_' . $node->type, $value = 1,
        variable_get('signup_nodeapi_' . $node->type, FALSE) == 1,
        t('if selected, users will be allowed to do signups for this node type'), $attributes = NULL,
        $required = FALSE);
        break;
    case 'form post':
        if($node->signup || variable_get('signup_nodeapi_' . $node->type, 0)) {

          //pull the signup admin form data for this node, and display the form
          $result = db_fetch_object(db_query("SELECT * FROM {signup} WHERE nid = %d", ($node->nid ? $node->nid : 0)));
          $node->signup = 1;
          $node->signup_forwarding_email = $result->forwarding_email;
          $node->signup_send_confirmation = $result->send_confirmation;
          $node->signup_confirmation_email = $result->confirmation_email;
          $node->signup_send_reminder  = $result->send_reminder ;
          $node->signup_reminder_days_before = $result->reminder_days_before;
          $node->signup_reminder_email = $result->reminder_email;
          $node->signup_completed = $result->completed;

          return _signup_admin_form($node);
        }
        elseif (user_access('admin signups')) {
          return form_checkbox(t('Enable signups for this node'), 'signup_enable');
        }
      break;

    case 'insert':

      //if it's a signup enabled node, then insert a new row for this node
      if (variable_get('signup_nodeapi_' . $node->type, 0)) {
        db_query("INSERT INTO {signup} (nid, forwarding_email, send_confirmation, confirmation_email,
        send_reminder, reminder_days_before, reminder_email) VALUES (%d, '%s', %d, '%s', %d, %d, '%s')",
        $node->nid, $edit['signup_forwarding_email'], $edit['signup_send_confirmation'], $edit['signup_confirmation_email'],
        $edit['signup_send_reminder'], $edit['signup_reminder_days_before'], $edit['signup_reminder_email']);
      }
      elseif ($edit['signup_enable']) {
        $defaults = db_fetch_array(db_query('SELECT * FROM {signup} WHERE nid = 0'));
        db_query("INSERT INTO {signup} (nid, forwarding_email, send_confirmation, confirmation_email,
        send_reminder, reminder_days_before, reminder_email) VALUES (%d, '%s', %d, '%s', %d, %d, '%s')",
        $node->nid, $defaults['forwarding_email'], $defaults['send_confirmation'], $defaults['confirmation_email'],
        $defaults['send_reminder'], $defaults['reminder_days_before'], $defaults['reminder_email']);
      }
      break;

    case 'update':

      //if this is a signup enabled node, then update the signup info for the node
      if (db_num_rows(db_query('SELECT * FROM {signup} WHERE nid = %d', $node->nid))) {
        db_query("UPDATE {signup} SET forwarding_email  = '%s', send_confirmation = %d, confirmation_email  = '%s',
          send_reminder = %d, reminder_days_before = %d, reminder_email = '%s'
          WHERE nid = %d", $node->signup_forwarding_email, $node->signup_send_confirmation,
          $node->signup_confirmation_email, $node->signup_send_reminder, $node->signup_reminder_days_before,
          $node->signup_reminder_email, $node->nid);
      }
      elseif ($edit['signup_enable']) {
        $defaults = db_fetch_array(db_query('SELECT * FROM {signup} WHERE nid = 0'));
        db_query("INSERT INTO {signup} (nid, forwarding_email, send_confirmation, confirmation_email,
        send_reminder, reminder_days_before, reminder_email) VALUES (%d, '%s', %d, '%s', %d, %d, '%s')",
        $node->nid, $defaults['forwarding_email'], $defaults['send_confirmation'], $defaults['confirmation_email'],
        $defaults['send_reminder'], $defaults['reminder_days_before'], $defaults['reminder_email']);
      }
      elseif (variable_get('signup_form_' . $node->type, 0)) {
        db_query("INSERT INTO {signup} (nid, forwarding_email, send_confirmation, confirmation_email,
          send_reminder, reminder_days_before, reminder_email) VALUES (%d, '%s', %d, '%s', %d, %d, '%s')",
          $node->nid, $edit['forwarding_email'], $edit['send_confirmation'], $edit['confirmation_email'],
          $edit['send_reminder'], $edit['reminder_days_before'], $edit['reminder_email']);
      }
      break;

    case 'delete':

        //clean up the signup tables for the deleted node
        db_query("DELETE FROM {signup} WHERE nid = %d", $node->nid);
        db_query("DELETE FROM {signup_log} WHERE nid = %d", $node->nid);
      break;

    case 'load':

      //check for a signup for this node.  if it's a new node, load the defaults
      $result = db_query("SELECT * FROM {signup} WHERE nid = %d", ($node->nid ? $node->nid : 0));

      //load signup data for both new nodes w/ enabled node types, and any existing nodes that are already signup enabled
      if ((!$node->nid && variable_get('signup_nodeapi_' . $node->type, 0)) || ($node->nid && db_num_rows($result))) {                     $signup = db_fetch_object($result);
        $node->signup = 1;
        $node->signup_forwarding_email = $signup->forwarding_email;
        $node->signup_send_confirmation = $signup->send_confirmation;
        $node->signup_confirmation_email = $signup->confirmation_email;
        $node->signup_send_reminder  = $signup->send_reminder ;
        $node->signup_reminder_days_before = $signup->reminder_days_before;
        $node->signup_reminder_email = $signup->reminder_email;
        $node->signup_completed = $signup->completed;
      }

      break;
    case 'view':

      $suppress = module_invoke_all('signup_suppress', $node);

      //if this is a signup node, start checks for what's to be printed
      if ($node->signup && ($_POST['op']) != t('Preview') && !in_array(TRUE, $suppress)) {
        global $user;

        //the node has been closed for signups, and the user has signup permissions.  let them know it's closed
        if ($node->signup_completed) {
          if (user_access('allow signups')) {
            $output = '<h3>' . t('Signups closed for this event') . '</h3>';
          }
        } else {

          //this is an anonymous user. if they have signup permissions, then display a login link
          if ($user->uid == 0) {
            $node->body .= user_access('allow signups') ? '<div class="signup_anonymous">'. t('<p>Please %login to sign up for this event.</p>',
            array("%login"=> l(t('login/register'), 'user/login', array(), drupal_get_destination()))) .'</div>' : '';
            break;
          }

          //check here to see if the user is already signed up for this node
          $result = db_query("SELECT signup_time, form_data FROM {signup_log} WHERE uid = %d AND nid =%d",
          $user->uid, $node->nid);
          $hidden = form_hidden('nid', $node->nid) . form_hidden('uid', $user->uid);

          if(db_num_rows($result) == 0) {

            //user isn't signed up, so check to make sure they have signup
            //permissions.  if this is the case, then print the themed signup form
            if (user_access('allow signups')) {
              $form_data = theme('signup_user_form') . $hidden . form_submit(t('Sign up'));
              $form = form($form_data, 'post', url('signup', drupal_get_destination()));
              $output = form_group(t('Sign up for %title', array('%title'=> check_plain($node->title))), $form);
            }

          //the user is already signed up, so print a table of their signup data, and give them the option to cancel
          } else {
            $result = db_fetch_object($result);
            $form_data = unserialize($result->form_data);
            $header = array(array('data' => t('Your signup information'), 'colspan' => 2));
            $rows = array();
            if(is_array($form_data)) {
              foreach ($form_data as $key => $value) {
                $rows[] = array($key . ':', check_plain($value));
              }
            }
            $output = theme('table', $header, $rows) . form($hidden . form_submit(t('Cancel Signup')), 'post',
              url('signup', drupal_get_destination()));
          }
        }

        //if user has signup perm, and signup_user_view is enabled, then display the current signups
        //pull all user signed up for this event, and start table creation
        if (user_access('allow signups') && variable_get('signup_user_view', 0)) {
          $signups = db_query("SELECT u.uid, u.name, s.signup_time, s.form_data FROM {signup_log} s INNER JOIN {users} u ON
    u.uid = s.uid WHERE s.nid =%d", $node->nid);
          $header = array(array('data' => t('%d individual(s) signed up', array('%d' => db_num_rows($signups)))));
          $rows = array();

          //loop through the users
          while ($signed_up_user = db_fetch_object($signups)) {

            //build the row for this user
            $rows[] = array(l(check_plain($signed_up_user->name), "user/$signed_up_user->uid"));
          }
          $output .= theme('table', $header, $rows);
        }
        $node->body .= $output;
      }
      break;
  }
}

/**
 * @defgroup signup_callback Functions which are the menu callbacks for this module
 */

/**
 * Prints the admin signup overview page located at admin/signup
 * @ingroup signup_callback
 */
function signup_admin_page() {

  $output = '';
  drupal_set_title(t('Signups'));

  //tests for optional support of event.module
  $_EVENT = module_exist('event');
  $event_select = $_EVENT ? ', e.event_start, e.timezone' : '';
  $event_join = $_EVENT ? ' LEFT JOIN {event} e ON e.nid = n.nid' : '';

  $header = array(
    array('data' => t('Event'), 'field' => 'n.title', 'sort' => 'asc'),
    array('data' => t('Signups'), 'field' => 'count'),
    array('data' => t('Operations')),
  );

  //if event module enabled, then add event start time to table
  if ($_EVENT) {
    $header = array_merge(array(array('data' => t('Start'), 'field' => 'e.event_start')), $header);
  }
  //pull all open signup nodes, and start the creation of the table
  $sql = "SELECT n.title, n.nid$event_select, COUNT(*) AS count FROM
          {signup} s INNER JOIN {node} n ON n.nid = s.nid INNER JOIN {signup_log} s_l
           ON s.nid = s_l.nid$event_join WHERE s.completed = 0 GROUP BY n.nid";
  $sql .= tablesort_sql($header);
  $result = pager_query($sql, 25);

  //loop through the signup nodes, pull the number of signups for each, and create the summary table
  while ($signup_event = db_fetch_object($result)) {
    $row = array();
    if ($_EVENT) {
      $offset = $signup_event->event_start ? event_get_offset($signup_event->timezone, $signup_event->event_start) : '';
      $row[] = $signup_event->event_start ?_event_date(variable_get('signup_date_string', 'D, M jS, g:i A'),
        $signup_event->event_start, $offset) : '';
    }
    $row[] = l(check_plain($signup_event->title), "node/$signup_event->nid");
    $row[] = $signup_event->count;
    $row[] = l(t('View Signups'), "node/$signup_event->nid/signups") .'<br>'. l(t('Close Event'),
      "closesignup/$signup_event->nid");
    $rows[] = $row;
  }
  $output .= theme('table', $header, $rows);
  $pager = theme('pager', NULL, 25, 0, tablesort_pager());
  if (!empty($pager)) {
    $output .= $pager;
  }
  print theme('page', $output);
}

/**
 * Callback function for canceling signups
 * @ingroup signup_callback
 */
function signup_cancel_signup($uid, $nid) {

  //delete the selected user from the log table and return to the previous page
  db_query("DELETE FROM {signup_log} WHERE uid = %d AND nid = %d", $uid, $nid);
  $node = db_fetch_object(db_query("SELECT nid, title FROM {node} WHERE nid = %d", $nid));
  drupal_set_message(t('Signup to %title cancelled', array('%title' => l(check_plain($node->title), "node/$node->nid"))));
  drupal_goto();

}


/**
 * Callback function for closing signups
 * @ingroup signup_callback
 */
function signup_close_signup($nid, $cron = 'no') {

  //close the specified node for signups, and head back to the admin/signup page if it's not a cron task
  db_query("UPDATE {signup} SET completed = 1 WHERE nid = %d", $nid);
  if ($cron == 'no') {
    drupal_goto('admin/signup');
  }
}

/**
 * Callback function for generating a detail report of signup conflicts
 * @ingroup signup_callback
 */
function signup_conflict_detail() {

  //pull all users who have signed up for a node
  $result = db_query('SELECT DISTINCT u.uid, u.name FROM {users} u INNER JOIN {signup_log} s on u.uid = s.uid ORDER BY u.name');

  //for each user, build a conflict detail section, and add their number of conflicts to the total
  while ($user = db_fetch_object($result)) {
    $conflicts = _signup_user_conflicts($user->uid);
    if (isset($conflicts)) {
      $sum .= $conflicts['title'] . $conflicts['data'];
      $total_conflicts += $conflicts['total'];
    } else {
      $sum .= t('<h4>%user, 0 schedule conflicts</h4>', array('%user' => l($user->name, "user/$user->uid")));
    }
  }

  //list the number of conflicts at the top of the page
  if (isset($total_conflicts)) {
    $output = t('<h2>%total total %conflict</h2>', array('%total' => $total_conflicts, '%conflict' => format_plural($total_conflicts, t('conflict'), t('conflicts')))) . $sum;
  } else {
    $output = t('<h2>No schedule conflicts</h2>');
  }
  print theme('page', $output);
}

/**
 * Callback function for generating a summary report of signup conflicts
 * @ingroup signup_callback
 */
function signup_conflict_summary() {

  //pull all users who have signed up for a node
  $result = db_query('SELECT DISTINCT u.uid, u.name FROM {users} u INNER JOIN {signup_log} s on u.uid = s.uid ORDER BY u.name');

  //for each user, build summary table row, and add their number of conflicts to the total
  while ($user = db_fetch_object($result)) {
    $conflicts = _signup_user_conflicts($user->uid);
    $user_total = (count($conflicts) ? $conflicts['total'] : 0);
    $rows[] = array(l($user->name, "user/$user->uid"), $user_total);
    $total_conflicts += $user_total;
  }

  //list the number of conflicts at the top of the page
  if ($total_conflicts > 0) {
    $header = array(t('user'), t('conflicts'));
    $output = t('<h2>%total total %conflict</h2>', array('%total' => $total_conflicts, '%conflict' => format_plural($total_conflicts, t('conflict'), t('conflicts'))));
    $output .= theme('table', $header, $rows);
  } else {
    $output = t('<h2>No schedule conflicts</h2>');
  }
  print theme('page', $output);
}

/**
 * Prints the settings page under admin/setttings/signup
 * @ingroup signup_callback
 */
function signup_settings_page() {
  $op = $_POST['op'];
  $edit = $_POST['edit'];

  //if the form has been submitted, update the data in the database
  switch ($op) {
    case t('Submit'):
      variable_set('signup_user_view', $edit['signup_user_view']);
      if (db_num_rows(db_query('SELECT nid FROM {signup} WHERE nid = 0'))) {
        db_query("UPDATE {signup} SET forwarding_email  = '%s', send_confirmation = %d, confirmation_email  = '%s',
            send_reminder = %d, reminder_days_before = %d, reminder_email = '%s'
            WHERE nid = 0", $edit['signup_forwarding_email'], $edit['signup_send_confirmation'],
            $edit['signup_confirmation_email'], $edit['signup_send_reminder'], $edit['signup_reminder_days_before'],
            $edit['signup_reminder_email']);

      } else {
        db_query("INSERT INTO {signup} VALUES(0, '%s', %d, '%s', %d, %d, '%s', 0, 0, '', 0)", $edit['signup_forwarding_email'],
        $edit['signup_send_confirmation'], $edit['signup_confirmation_email'], $edit['signup_send_reminder'],
        $edit['signup_reminder_days_before'], $edit['signup_reminder_email']);
      }
      drupal_set_message(t('Signup settings updated'));
      break;
  }

  //print the settings page
  $output = form_checkbox(t('Users can view signups'), 'signup_user_view', 1, variable_get('signup_user_view', 0),
    t('Selecting this option allows users with signup permissions to see who has already signed up.'));
  $output .= '<h2>' . t('Default signup information') . '</h2><br>' . t('New signup nodes will start with these settings');
  $output .= _signup_admin_form($node);
  $output .= form_submit(t('Submit'));
  print theme('page', form($output));
}

/**
 * Callback function which prints a schedule of user's signups
 * @ingroup signup_callback
 */
function signup_user_schedule() {

  $output = '';
  $user = user_load(array('uid' => arg(1)));
  drupal_set_title(t('Signups for %user', array('%user' => $user->name)));

  $titles = _signup_list_user_signups($user->uid);

  // theme each signup
  foreach ($titles as $nid => $title) {
    $node = node_load(array('nid' => $nid));
    $output .= theme('signup_user_schedule', $node);
  }

  print theme('page', $output);
}

/**
 * Callback function which handles sending of emails upon user signup, and signup cancellations
 * @ingroup signup_callback
 */
function signup_user_signup() {

  $op = $_POST['op'];
  $edit = $_POST['edit'];

  global $user;

  switch ($op) {
    case t("Sign up"):
      _signup_sign_up_user();

      break;

    //user has elected to cancel their signup, so delete them from the log, and warn
    case t('Cancel Signup'):
      signup_cancel_signup($edit['uid'], $edit['nid']);
      break;
  }

  //send the user back to the same page, or to node if it's not available
  $dest = $_REQUEST['destination'];
  unset($_REQUEST['destination']);
  if ($dest) {
    //go back to the original node...
    drupal_goto($dest);
  } else {
    // last resort
    drupal_goto('node');
  }

}

/**
 * Prints the signup details for a single node when the signups tab is clicked
 * @ingroup signup_callback
 */
function signup_user_signups_form($node) {

  //pull all user signed up for this event, and start table creation
  $result = db_query("SELECT u.uid, u.name, s.signup_time, s.form_data FROM {signup_log} s INNER JOIN {users} u ON
    u.uid = s.uid WHERE s.nid =%d", $node->nid);
  $output = "<h1>" . check_plain($node->title) . "</h1>";
  $header = array(array('data' => t('%d individual(s) signed up', array('%d' => db_num_rows($result))), 'colspan' => 3));
  $rows = array();

  //get default timezone offset for the site
  $offset = intval(variable_get('date_default_timezone', 0));

  //loop through the users, unserializing their user data
  while ($signed_up_user = db_fetch_object($result)) {
    $table_data = array();
    $form_data = unserialize($signed_up_user->form_data);

    //compose the user data
    foreach ($form_data as $key => $value) {
      $table_data[] = $key . ': ' . check_plain($value);
    }

    //build the row for this user
    $rows[] = array(l(check_plain($signed_up_user->name), "user/$signed_up_user->uid") .'<br>'.
      gmdate(variable_get('signup_date_string', 'M jS, g:i A'), $signed_up_user->signup_time - $offset),
      implode('<br>', $table_data), form(form_hidden('nid', $node->nid) . form_hidden('uid', $signed_up_user->uid) .
      form_submit(t('Cancel Signup')), 'post', url('signup', drupal_get_destination())));
  }
  $output .= theme('table', $header, $rows);
  print theme('page', $output);
}

/**
 * @defgroup signup_internal Internal module functions
 */

/**
 * Returns the signup admin form to either the settings page or the node edit page
 * @ingroup signup_internal
 */
function _signup_admin_form($node) {

  //load the default admin form data for new nodes
  if(!$node) {
    $result = db_fetch_object(db_query("SELECT * FROM {signup} WHERE nid = 0"));
    $node->signup_forwarding_email = $result->forwarding_email;
    $node->signup_send_confirmation = $result->send_confirmation;
    $node->signup_confirmation_email = $result->confirmation_email;
    $node->signup_send_reminder  = $result->send_reminder;
    $node->signup_reminder_days_before = $result->reminder_days_before;
    $node->signup_reminder_email = $result->reminder_email;
  }

  //compose the form fields
  $form = '';
  $form .= form_textfield(t('Send signups to'), 'signup_forwarding_email', $node->signup_forwarding_email, 40, 64,
    $description = t('Email address where notification of new signups will be sent. Leave blank for no notifications'),
    $attributes = NULL, $required = FALSE);
  $form .= form_checkbox(t('Send confirmation'), 'signup_send_confirmation', $value = 1, $node->signup_send_confirmation,
    $description = NULL, $attributes = NULL, $required = FALSE);
  $form .= form_textarea(t('Confirmation email'), 'signup_confirmation_email', $node->signup_confirmation_email, 40, 6,
    $description = t('Email sent to user upon signup. Supported string substitutions: %event, %time, %username, %useremail,
    %info (user signup information)'), $attributes = NULL, $required = FALSE);
  $form .= '<div class="container-inline">' . form_checkbox(t('Send reminder'), 'signup_send_reminder', $value = 1,
    $node->signup_send_reminder, $description = NULL, $attributes = NULL, $required = FALSE);
  $options = array ();
  for ($i = 1; $i <= 60; $i++) {
    $options[$i] = $i;
  }
  $form .= form_select('', 'signup_reminder_days_before', $node->signup_reminder_days_before, $options, $description = NULL,
    $extra = 0, $multiple = FALSE, $required = FALSE);
  $form .= "day(s) before event</div>";
  $form .= form_textarea(t('Reminder email'), 'signup_reminder_email', $node->signup_reminder_email, 40, 6,
    $description = t('Email sent to user as an event reminder. Supported string substitutions: %event, %time, %username,
    %useremail'), $attributes = NULL, $required = FALSE);
  $form .= form_hidden('signup', 1, $edit = 'edit');

  return form_group(t('Signup information'), $form, $description = NULL, $attributes = NULL);
}

/**
 * Returns an array of conflict information for the specified uid
 * @ingroup signup_internal
 */
function _signup_get_conflicts($uid) {

  $conflicts = array();
  if (module_exist('event')) {

    //pull all signup nodes for the specified user
    $signups = db_query('SELECT n.nid, n.title, e.event_start AS start, e.event_end AS end FROM {signup_log} s INNER JOIN {node} n ON s.nid = n.nid INNER JOIN {event} e ON n.nid = e.nid WHERE s.uid = %d', $uid);

    //for each signup, pull all nodes that have a time conflict.  ignore duplicate conflicts
    while ($events = db_fetch_array($signups)) {
      $nid = $events['nid'];
      $title = $events['title'];
      $end = $events['end'];
      $start = $events['start'];
      $nodes[$nid][] = (integer) $nid;
      $skip = implode(', ', $nodes[$nid]);
      $conflicting = db_query('SELECT n.nid, n.title, e.event_start AS start, e.event_end AS end FROM {signup_log} s INNER JOIN {node} n ON s.nid = n.nid INNER JOIN {event} e ON n.nid = e.nid WHERE s.uid = %d AND ((event_start < %d AND event_start > %d) OR(event_end < %d AND event_end > %d) OR (event_end >= %d AND event_start <= %d)) AND n.nid NOT IN(%s)', $uid, $end, $start, $end, $start, $end, $start, $skip);

      //if there are conflicts, build a conflict array.  mark conflicts to prevent duplicates
      if (db_num_rows($conflicting)) {
        $conflicts[$nid][] = array('nid' => $nid, 'title' => $title, 'start' => $start, 'end' => $end);
        while ($conflict = db_fetch_array($conflicting)) {
          $conflicts[$nid][] = $conflict;
          $total_conflicts++;
          $nodes[$conflict['nid']][] = $nid;
        }
      }
    }

    if ($conflicts) {
      $conflicts['total'] = $total_conflicts;
    }
  }
  return $conflicts;
}

/**
 * Returns an array of node titles w/ links for all events the specified user has signed up for
 * @ingroup signup_internal
 */
function _signup_list_user_signups($uid) {

  $titles = array();

  //tests for optional support of event.module
  $_EVENT = module_exist('event');
  $event_join = $_EVENT ? ' LEFT JOIN {event} e ON e.nid = n.nid' : '';
  $event_where = $_EVENT ? ' AND (e.event_start >= '. time() . ' OR e.event_start IS NULL)' : '';
  $order_by = $_EVENT ? 'e.event_start' : 'n.title';

  //pull all open signup nodes for this user
  $result = db_query("SELECT n.title, n.nid FROM {signup_log} s_l INNER JOIN {node} n ON n.nid = s_l.nid
    $event_join WHERE s_l.uid = '%s'$event_where ORDER BY $order_by", $uid);

  while ($node = db_fetch_array($result)) {
    $titles[$node['nid']] = l($node['title'], 'node/'. $node['nid']);
  }
  return $titles;
}

/**
 * Signs up a user to a node. NOTE: other modules can call this function. To do so, edit must be as follows:
 *
 * edit['nid'] : nid of the node to which the user will be signed up
 * edit['uid'] : uid of the user to sign up
 * $edit['signup_form_data'] : an array of key/value pairs -- key is the data category, value is the user input
 *
 * @ingroup signup_internal
 */
function _signup_sign_up_user($edit = NULL) {

  $edit = $edit ? $edit : $_POST['edit'];
  $user = user_load(array('uid' => $edit['uid']));

  if (user_access('allow signups')) {
    //this check is in case a node type was enabled, and the node the user is trying to sign up for is not in
    //the signup table. this would be the case for all nodes created when signup.module was not enabled.  if
    //no row exists for this node, then grab the signup defaults and create a new row before proceeding
    if (db_num_rows(db_query("SELECT * FROM {signup} WHERE nid = %d", $edit['nid'])) == 0) {
      $defaults = db_fetch_object(db_query("SELECT * FROM {signup} WHERE nid = 0"));
      db_query("INSERT INTO {signup} (nid, forwarding_email, send_confirmation, confirmation_email,
          send_reminder, reminder_days_before, reminder_email) VALUES (%d, '%s', %d, '%s', %d, %d, '%s')",
      $edit['nid'], $defaults->signup_forwarding_email, $defaults->signup_send_confirmation,
      $defaults->signup_confirmation_email, $defaults->signup_send_reminder, $defaults->signup_reminder_days_before,
      $defaults->signup_reminder_email);
    }

    //get current time and serialize the user's signup data
    $curtime = time();
    $signup_form_data = serialize($edit['signup_form_data']);

    //pull this event from the signup table, determine if reminder/confirmation emails are going to be sent,
    //and inform the user
    $event = db_fetch_object(db_query("SELECT * FROM {signup} WHERE nid = %d", $edit['nid']));
    $confirmation_email = $event->send_confirmation ? '  ' . t('You will receive a confirmation email shortly
        which contains further event information.') : '';
    $reminder_email = $event->send_reminder ? '  ' . t('You will receive a reminder email %number %days before the event.',
    array('%number' => $event->reminder_days_before, '%days' => format_plural($event->reminder_days_before, t('day'), t('days')))) : '';

    //insert the user into the signup_log
    db_query("INSERT INTO {signup_log} (uid, nid, signup_time, form_data) VALUES
        (%d, %d, %d, '%s')", $edit['uid'], $edit['nid'], $curtime, $signup_form_data);

    //load the node, format the start time, and compose the user's signup data for later use in the emails
    $node = node_load(array('nid'=> $edit['nid']));
    $offset = $node->event_start ? event_get_offset($node->timezone, $node->event_start) : '';
    $starttime = $node->event_start ? _event_date(variable_get('signup_date_string', 'D, M jS, g:i A'),
    $node->event_start, $offset) : t('[Untimed]');
    $signup_data_array = array();
    foreach ($edit['signup_form_data'] as $key => $value) {
      $signup_data_array[] = $key . ': ' . $value;
    }
    $signup_data = t('SIGNUP INFORMATION') . "\n\r\n\r" . implode("\n\r", $signup_data_array);
    $trans = array("%event" => $node->title, "%time" => $starttime, "%username" => $user->name,
    "%useremail" => $user->mail, "%info" => $signup_data);

    //if a confirmation is to be sent, compose the mail message, translate the string substitutions, and send it
    if ($event->send_confirmation && $user->mail) {
      $header = "From: $event->forwarding_email\nReply-to: $event->forwarding_email\nX-Mailer:
          Drupal\nReturn-path: $event->forwarding_email\nErrors-to: $event->forwarding_email";
      $subject = t('Signup confirmation for event: %event', array('%event' => $node->title));
      $message = strtr($event->confirmation_email, $trans);
      user_mail($user->mail, $subject, $message, $header);
    }

    //if a forwarding email is to be sent, compose the mail message, translate the string substitutions, and send it
    if ($event->forwarding_email) {
      $site_mail = variable_get('site_mail', 'noadmin@noadmin.com');
      $header = "From: " . t('New Event Signup') . "\nReply-to: $site_mail\nX-Mailer:
          Drupal\nReturn-path: $site_mail\nErrors-to: $site_mail";
      $subject = t('Signup confirmation for event: %title', array('%title' => $node->title));
      $message = t('The following information was submitted as a signup for %title', array('%title' => $node->title)) .
      "\n\r" . t('Date/Time: %time', array('%time'=>$starttime)) . ":\n\r\n\r\n\r" . t('username:') . $user->name .
      "\n\r" . t('email:') . $user->mail . "\n\r\n\r" . $signup_data;
      user_mail($event->forwarding_email, $subject, $message, $header);
    }
    drupal_set_message(t('Signup to %title confirmed.', array('%title' => l(check_plain($node->title), "node/$node->nid"))) . $confirmation_email . $reminder_email);
  } else {
    drupal_access_denied();
  }
}

/**
 * Returns a formatted list of conflict information for the specified user
 * @ingroup signup_internal
 */
function _signup_user_conflicts($uid) {

  $user = user_load(array('uid' => $uid));
  $conflicts = _signup_get_conflicts($uid);

  //if there are conflicts, pull the total from the array, and build a title section
  if (count($conflicts)) {
    $return['total'] = array_pop($conflicts);
    $return['title'] = t('<h4>%user, %total schedule %conflict:</h4>', array('%total' => $return['total'], '%conflict' => format_plural($return['total'], t('conflict'), t('conflicts')), '%user' => l($user->name, "user/$user->uid")));

    $output = '';

    //pull the main event off the array, and then loop through and put all the conflicts to that event in an item list
    foreach($conflicts as $nid) {
      $list = array();
      $node = array_shift($nid);
      $output .= l(check_plain($node['title']), 'node/'. $node['nid']) .' '. t('conflicts with:');
      foreach ($nid as $conflict) {
        $list[] = l(check_plain($conflict['title']), 'node/'. $conflict['nid']);
      }
      $output .= theme('item_list', $list);
    }
    $return['data'] = $output;
  }
  return $return;
}
?>